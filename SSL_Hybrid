
//@version=6
indicator("SSL Hybrid + SMA 20/50/200", overlay=true)

// ==== Inputok ====
show_Baseline = input.bool(true, title="Show Baseline")
show_SSL1 = input.bool(false, title="Show SSL1")
show_atr = input.bool(false, title="Show ATR bands")
//ATR
atrlen = input.int(14, "ATR Period", display=display.none)
mult = input.float(1, "ATR Multi", step=0.1, display=display.none)
smoothing = input.string("WMA", title="ATR Smoothing", options=["RMA", "SMA", "EMA", "WMA"], display=display.none)

// ATR számítás
ma_function(source, atrlen) =>
    if smoothing == "RMA"
        ta.rma(source, atrlen)
    else if smoothing == "SMA"
        ta.sma(source, atrlen)
    else if smoothing == "EMA"
        ta.ema(source, atrlen)
    else
        ta.wma(source, atrlen)

atr_slen = ma_function(ta.tr(true), atrlen)
upper_band = atr_slen * mult + close
lower_band = close - atr_slen * mult

// ---- MA típus választó ----
maType = input.string("HMA", title="SSL1 / Baseline Type", options=["SMA","EMA","DEMA","TEMA","LSMA","WMA","MF","VAMA","TMA","HMA", "JMA", "Kijun v2", "EDSMA","McGinley"],display=display.none)
len = input.int(25, title="SSL1 / Baseline Length", display=display.none)

SSL2Type = input.string("JMA", title="SSL2 / Continuation Type", options=["SMA","EMA","DEMA","TEMA","WMA","MF","VAMA","TMA","HMA", "JMA","McGinley"], display=display.none)
len2 = input.int(5, title="SSL 2 Length", display=display.none)

SSL3Type = input.string("HMA", title="EXIT Type", options=["DEMA","TEMA","LSMA","VAMA","TMA","HMA","JMA", "Kijun v2", "McGinley", "MF"], display=display.none)
len3 = input.int(15, title="EXIT Length", display=display.none)
src = input.source(close, title="Source", display=display.none)

// ---- MA függvény (rövidítve nem módosítom, teljes kód marad) ----
tema(src, len) =>
    ema1 = ta.ema(src, len)
    ema2 = ta.ema(ema1, len)
    ema3 = ta.ema(ema2, len)
    (3 * ema1) - (3 * ema2) + ema3

kidiv = input.float(1, title="Kijun MOD Divider", maxval=4, display=display.none)
jurik_phase = input.int(3, title="* Jurik (JMA) Only - Phase", display=display.none)
jurik_power = input.int(1, title="* Jurik (JMA) Only - Power", display=display.none)
volatility_lookback = input.int(10, title="* Volatility Adjusted (VAMA) Only - Volatility lookback length", display=display.none)
beta = input.float(0.8, title="Modular Filter Beta", minval=0, maxval=1, step=0.1, display=display.none)
feedback = input.bool(false, title="Modular Filter Feedback", display=display.none)
z = input.float(0.5, title="MF Feedback Weighting", step=0.1, minval=0, maxval=1, display=display.none)
ssfLength = input.int(20, title="EDSMA Filter Length", minval=1, display=display.none)
ssfPoles = input.int(2, title="EDSMA Poles", options=[2, 3], display=display.none)

//EDSMA
get2PoleSSF(src, length) =>
    PI = 2 * math.asin(1)
    arg = math.sqrt(2) * PI / length
    a1 = math.exp(-arg)
    b1 = 2 * a1 * math.cos(arg)
    c2 = b1
    c3 = -math.pow(a1, 2)
    c1 = 1 - c2 - c3
    
    var float ssf = 0.0
    ssf := c1 * src + c2 * nz(ssf[1]) + c3 * nz(ssf[2])
    ssf

get3PoleSSF(src, length) =>
    PI = 2 * math.asin(1)

    arg = PI / length
    a1 = math.exp(-arg)
    b1 = 2 * a1 * math.cos(1.738 * arg)
    c1 = math.pow(a1, 2)

    coef2 = b1 + c1
    coef3 = -(c1 + b1 * c1)
    coef4 = math.pow(c1, 2)
    coef1 = 1 - coef2 - coef3 - coef4

    var float ssf = 0.0
    ssf := coef1 * src + coef2 * nz(ssf[1]) + coef3 * nz(ssf[2]) + coef4 * nz(ssf[3])
    ssf

ma(type, src, len) =>
    float result = 0
    if type=="TMA"
        result := ta.sma(ta.sma(src, math.ceil(len / 2)), math.floor(len / 2) + 1)
    else if type=="MF"
        var float ts = 0.
        var float b = 0.
        var float c = 0.
        var float os = 0.
        //----
        alpha = 2/(len+1)
        a = feedback ? z*src + (1-z)*nz(ts[1],src) : src
        //----
        b := a > alpha*a+(1-alpha)*nz(b[1],a) ? a : alpha*a+(1-alpha)*nz(b[1],a)
        c := a < alpha*a+(1-alpha)*nz(c[1],a) ? a : alpha*a+(1-alpha)*nz(c[1],a)
        os := a == b ? 1 : a == c ? 0 : os[1]
        //----
        upper = beta*b+(1-beta)*c
        lower = beta*c+(1-beta)*b 
        ts := os*upper+(1-os)*lower
        result := ts
    else if type=="LSMA"
        result := ta.linreg(src, len, 0)
    else if type=="SMA" // Simple
        result := ta.sma(src, len)
    else if type=="EMA" // Exponential
        result := ta.ema(src, len)
    else if type=="DEMA" // Double Exponential
        e = ta.ema(src, len)
        result := 2 * e - ta.ema(e, len)
    else if type=="TEMA" // Triple Exponential
        e = ta.ema(src, len)
        result := 3 * (e - ta.ema(e, len)) + ta.ema(ta.ema(e, len), len)
    else if type=="WMA" // Weighted
        result := ta.wma(src, len)
    else if type=="VAMA" // Volatility Adjusted
        /// Copyright © 2019 to present, Joris Duyck (JD)
        mid=ta.ema(src,len)
        dev=src-mid
        vol_up=ta.highest(dev,volatility_lookback)
        vol_down=ta.lowest(dev,volatility_lookback)
        result := mid+math.avg(vol_up,vol_down)
    else if type=="HMA" // Hull
        result := ta.wma(2 * ta.wma(src, len / 2) - ta.wma(src, len), math.round(math.sqrt(len)))
    else if type=="JMA" // Jurik
        /// Copyright © 2018 Alex Orekhov (everget)
        /// Copyright © 2017 Jurik Research and Consulting.
        phaseRatio = jurik_phase < -100 ? 0.5 : jurik_phase > 100 ? 2.5 : jurik_phase / 100 + 1.5
        beta_jma = 0.45 * (len - 1) / (0.45 * (len - 1) + 2)
        alpha = math.pow(beta_jma, jurik_power)
        var float jma = 0.0
        var float e0 = 0.0
        var float e1 = 0.0
        var float e2 = 0.0
        e0 := (1 - alpha) * src + alpha * nz(e0[1])
        e1 := (src - e0) * (1 - beta_jma) + beta_jma * nz(e1[1])
        e2 := (e0 + phaseRatio * e1 - nz(jma[1])) * math.pow(1 - alpha, 2) + math.pow(alpha, 2) * nz(e2[1])
        jma := e2 + nz(jma[1])
        result := jma
    else if type=="Kijun v2"
        kijun = math.avg(ta.lowest(len), ta.highest(len))//, (open + close)/2)
        conversionLine = math.avg(ta.lowest(math.round(len/kidiv)), ta.highest(math.round(len/kidiv)))
        delta = (kijun + conversionLine)/2
        result :=delta
    else if type=="McGinley"
        var float mg = 0.0
        mg := na(mg[1]) ? ta.ema(src, len) : mg[1] + (src - mg[1]) / (len * math.pow(src/mg[1], 4))
        result :=mg
    else if type=="EDSMA"
        zeros = src - nz(src[2])
        avgZeros = (zeros + zeros[1]) / 2
        
        // Ehlers Super Smoother Filter 
        ssf = ssfPoles == 2
             ? get2PoleSSF(avgZeros, ssfLength)
             : get3PoleSSF(avgZeros, ssfLength)
        
        // Rescale filter in terms of Standard Deviations
        stdev = ta.stdev(ssf, len)
        scaledFilter = stdev != 0
             ? ssf / stdev
             : 0
        
        alpha = 5 * math.abs(scaledFilter) / len
        
        var float edsma = 0.0
        edsma := alpha * src + (1 - alpha) * nz(edsma[1])
        result := edsma
    result

///SSL 1 and SSL2
emaHigh = ma(maType, high, len)
emaLow = ma(maType, low, len)
maHigh = ma(SSL2Type, high, len2)
maLow = ma(SSL2Type, low, len2)
ExitHigh = ma(SSL3Type, high, len3)
ExitLow = ma(SSL3Type, low, len3)

///Keltner Baseline
BBMC = ma(maType, close, len)
useTrueRange = input.bool(true)
multy = input.float(0.2, title="Base Channel Multiplier", step=0.05, display=display.none)
Keltma = ma(maType, src, len)
range_T = useTrueRange ? ta.tr : high - low
rangema = ta.ema(range_T, len)
upperk = Keltma + rangema * multy
lowerk = Keltma - rangema * multy

// Baseline Violation
open_pos = open*1
close_pos = close*1
difference = math.abs(close_pos-open_pos)
atr_violation = difference > atr_slen
InRange = upper_band > BBMC and lower_band < BBMC
candlesize_violation = atr_violation and InRange
plotshape(candlesize_violation, color=color.white, size=size.tiny, style=shape.diamond, location=location.top, title="Candle Size > 1xATR")

// SSL1
var int Hlv = na
Hlv := close > emaHigh ? 1 : close < emaLow ? -1 : Hlv[1]
sslDown = Hlv < 0 ? emaHigh : emaLow

// SSL2
var int Hlv2 = na
Hlv2 := close > maHigh ? 1 : close < maLow ? -1 : Hlv2[1]
sslDown2 = Hlv2 < 0 ? maHigh : maLow

//COLORS
show_color_bar = input.bool(false, title="Color Bars")
color_bar = close > upperk ? #00c3ff : close < lowerk ? #ff0062 : color.gray
color_ssl1 = close > sslDown ? #00c3ff : close < sslDown ? #ff0062 : na

// EXIT
var int Hlv3 = na
Hlv3 := close > ExitHigh ? 1 : close < ExitLow ? -1 : Hlv3[1]
sslExit = Hlv3 < 0 ? ExitHigh : ExitLow
is_bullish_baseline = close > upperk
is_bearish_baseline = close < lowerk
base_cross_Long = ta.crossover(close, sslExit) and is_bullish_baseline
base_cross_Short = ta.crossover(sslExit, close) and is_bearish_baseline
codiff = base_cross_Long ? 1 : base_cross_Short ? -1 : na

// SL értékek
sl_value_long = close - atr_slen
sl_value_short = close + atr_slen
var label sl_label_long = na
var label sl_label_short = na

if base_cross_Long
    sl_label_long := label.new(x=bar_index, y=low - atr_slen * 0.5, text="SL: " + str.tostring(sl_value_long, "#.####"), style=label.style_label_up, color=color.red, textcolor=color.white, size=size.small)

if base_cross_Short
    sl_label_short := label.new(x=bar_index, y=high + atr_slen * 0.5, text="SL: " + str.tostring(sl_value_short, "#.####"), style=label.style_label_down, color=color.red, textcolor=color.white, size=size.small)

// ==== PLOTS ====

plotarrow(codiff, colorup=#00c3ff, colordown=#ff0062, title="Exit Arrows", maxheight=20, offset=0)

p1 = plot(show_Baseline ? BBMC : na, color=color_bar, linewidth=4, title='MA Baseline',  display=display.none)
DownPlot = plot(show_SSL1 ? sslDown : na, title="SSL1", linewidth=3, color=color.new(color_ssl1, 10), display=display.none)
barcolor(show_color_bar ? color_bar : na)
up_channel = plot(show_Baseline ? upperk : na, color=color_bar, title="Baseline Upper Channel", display=display.none)
low_channel = plot(show_Baseline ? lowerk : na, color=color_bar, title="Basiline Lower Channel", display=display.none)
fill(up_channel, low_channel, color=color.new(color_bar, 90))

// SSL2
LongPlot = plot(sslDown2, title="SSL2", linewidth=2, color=#8e6f42, style=plot.style_circles, display=display.none)

// ATR bands
u = plot(show_atr ? upper_band : na, "+ATR", color=color.new(color.white, 80), display=display.none)
l = plot(show_atr ? lower_band : na, "-ATR", color=color.new(color.white, 80), display=display.none)



// ==== SMA-k ====
group_sma = "Simple Moving Averages"

// SMA 7
show_sma7 = input.bool(true, title="Show SMA 7", group= group_sma)
sma7_color = input.color(color.rgb(138, 144, 167), title="SMA 7 Color", group=group_sma)
sma7 = ta.sma(close, 7)
plot(show_sma7 ? sma7 : na, title="SMA 7", color=sma7_color, linewidth=1, display=display.none)

show_sma20 = input.bool(true, title="Show SMA 20", group=group_sma)
sma20_color = input.color(color.rgb(38, 68, 204), title="SMA 20 Color", group=group_sma)
sma20 = ta.sma(close, 20)
plot(show_sma20 ? sma20 : na, title="SMA 20", color=sma20_color, linewidth=1, display=display.pane)

show_sma50 = input.bool(true, title="Show SMA 50", group=group_sma)
sma50_color = input.color(#e8a94b, title="SMA 50 Color", group=group_sma)
sma50 = ta.sma(close, 50)
plot(show_sma50 ? sma50 : na, title="SMA 50", color=sma50_color, linewidth=1, display=display.pane)

show_sma200 = input.bool(true, title="Show SMA 200", group=group_sma)
sma200_color = input.color(#ff9800, title="SMA 200 Color", group=group_sma)
sma200 = ta.sma(close, 200)
plot(show_sma200 ? sma200 : na, title="SMA 200", color=sma200_color, linewidth=2, display=display.pane)

// ==== Bollinger Bands ====
group_bb = "Bollinger Bands"
show_bb = input.bool(false, title="Show Bollinger Bands", group=group_bb)
bb_length = input.int(20, title="BB Length", group=group_bb)
bb_mult = input.float(2.0, title="BB Multiplier", step=0.1, group=group_bb)
bb_color = input.color(color.rgb(120, 144, 156), title="BB Color", group=group_bb)

bb_basis = ta.sma(close, bb_length)
bb_dev = bb_mult * ta.stdev(close, bb_length)
bb_upper = bb_basis + bb_dev
bb_lower = bb_basis - bb_dev

p_bb_basis = plot(show_bb ? bb_basis : na, title="BB Basis", color=bb_color, linewidth=1, display=display.pane)
p_bb_upper = plot(show_bb ? bb_upper : na, title="BB Upper", color=bb_color, linewidth=1, display=display.pane)
p_bb_lower = plot(show_bb ? bb_lower : na, title="BB Lower", color=bb_color, linewidth=1, display=display.pane)

fill(p_bb_upper, p_bb_lower, color=color.new(bb_color, 90))

// ==== Inputok ====
show_table = input.bool(true, title="Show Table")

// RSI inputok
rsi_length = input.int(14, "RSI Length", minval=2)
rsi_overbought = input.int(70, "RSI Overbought Level")
rsi_oversold = input.int(30, "RSI Oversold Level")
rsi_ext_lookback = input.int(200, "RSI Extremes Lookback")

// SMI inputok
smi_length = input.int(14, "SMI Length")
smi_smoothK = input.int(3, "SMI %K Smoothing")
smi_smoothD = input.int(3, "SMI %D Smoothing")
smi_overbought = input.int(40, "SMI Overbought")  // SMI tipikus: +/-40
smi_oversold = input.int(-40, "SMI Oversold")
smi_ext_lookback = input.int(200, "SMI Extremes Lookback")

// ==== RSI számítása ====
rsi_val = ta.rsi(close, rsi_length)
rsi_color = rsi_val > rsi_overbought ? color.red : rsi_val < rsi_oversold ? color.green : color.white
rsi_max = ta.highest(rsi_val, rsi_ext_lookback)
rsi_min = ta.lowest(rsi_val, rsi_ext_lookback)

// ==== OBV számítása ====
obv_val = ta.cum((close - close[1] >= 0 ? 1 : -1) * volume)
obv_color = obv_val > obv_val[1] ? color.green : color.red

// ==== SMI számítása ====
hh = ta.highest(high, smi_length)
ll = ta.lowest(low, smi_length)
mid = (hh + ll)/2
diff = close - mid
range2 = (hh - ll)/2
smi_raw = range2 != 0 ? diff / range2 * 100 : 0
smi_K = ta.sma(smi_raw, smi_smoothK)
smi_D = ta.sma(smi_K, smi_smoothD)
smi_max = ta.highest(smi_K, smi_ext_lookback)
smi_min = ta.lowest(smi_K, smi_ext_lookback)
smi_color = smi_K > smi_overbought ? color.red : smi_K < smi_oversold ? color.green : color.white

// ==== Táblázat létrehozása ====
var table stat_table = table.new(position.top_right, 1, 3, frame_color=color.gray, frame_width=1, border_width=1)

if show_table
    table.cell(stat_table, 0, 0, text="RSI: " + str.tostring(rsi_val, "#.##") + " (" + str.tostring(rsi_min, "#") + "-" + str.tostring(rsi_max, "#") + ")", text_color=rsi_color, bgcolor=color.new(color.black, 70))    
    table.cell(stat_table, 0, 1, text="SMI: " + str.tostring(smi_K, "#.##") + " (" + str.tostring(smi_min, "#") + "-" + str.tostring(smi_max, "#") + ")", text_color=smi_color, bgcolor=color.new(color.black, 70))
    table.cell(stat_table, 0, 2, text="OBV: " + str.tostring(obv_val, "#"), text_color=obv_color, bgcolor=color.new(color.black, 70))
